This article explains the new features in Python 3.7, compared to 3.6. Python 3.7 was released on June 27, 2018. For full details, see the changelog.Summary – Release HighlightsNew syntax features:PEP 563, postponed evaluation of type annotations.Backwards incompatible syntax changes:async and await are now reserved keywords.New library modules:contextvars: PEP 567 – Context Variablesdataclasses: PEP 557 – Data Classesimportlib.resourcesNew built-in features:PEP 553, the new breakpoint() function.Python data model improvements:PEP 562, customization of access to module attributes.PEP 560, core support for typing module and generic types.the insertion-order preservation nature of dict objects has been declared to be an official part of the Python language spec.Significant improvements in the standard library:The asyncio module has received new features, significant usability and performance improvements.The time module gained support for functions with nanosecond resolution.CPython implementation improvements:Avoiding the use of ASCII as a default text encoding:PEP 538, legacy C locale coercionPEP 540, forced UTF-8 runtime modePEP 552, deterministic .pycsthe new development runtime modePEP 565, improved DeprecationWarning handlingC API improvements:PEP 539, new C API for thread-local storageDocumentation improvements:PEP 545, Python documentation translationsNew documentation translations: Japanese, French, and Korean.This release features notable performance improvements in many areas. The Optimizations section lists them in detail.For a list of changes that may affect compatibility with previous Python releases please refer to the Porting to Python 3.7 section.New FeaturesPEP 563: Postponed Evaluation of AnnotationsThe advent of type hints in Python uncovered two glaring usability issues with the functionality of annotations added in PEP 3107 and refined further in PEP 526:annotations could only use names which were already available in the current scope, in other words they didn’t support forward references of any kind; andannotating source code had adverse effects on startup time of Python programs.Both of these issues are fixed by postponing the evaluation of annotations. Instead of compiling code which executes expressions in annotations at their definition time, the compiler stores the annotation in a string form equivalent to the AST of the expression in question. If needed, annotations can be resolved at runtime using typing.get_type_hints(). In the common case where this is not required, the annotations are cheaper to store (since short strings are interned by the interpreter) and make startup time faster.Usability-wise, annotations now support forward references, making the following syntax valid:class C:    @classmethod    def from_string(cls, source: str) -> C:        ...    def validate_b(self, obj: B) -> bool:        ...class B:    ...Since this change breaks compatibility, the new behavior needs to be enabled on a per-module basis in Python 3.7 using a __future__ import:from __future__ import annotationsIt will become the default in Python 4.0.See alsoPEP 563 – Postponed evaluation of annotationsPEP written and implemented by Łukasz Langa.PEP 538: Legacy C Locale CoercionAn ongoing challenge within the Python 3 series has been determining a sensible default strategy for handling the 7-bit ASCII” text encoding assumption currently implied by the use of the default C or POSIX locale on non-Windows platforms.PEP 538 updates the default interpreter command line interface to automatically coerce that locale to an available UTF-8 based locale as described in the documentation of the new PYTHONCOERCECLOCALE environment variable. Automatically setting LC_CTYPE this way means that both the core interpreter and locale-aware C extensions (such as readline) will assume the use of UTF-8 as the default text encoding, rather than ASCII.The platform support definition in PEP 11 has also been updated to limit full text handling support to suitably configured non-ASCII based locales.As part of this change, the default error handler for stdin and stdout is now surrogateescape (rather than strict) when using any of the defined coercion target locales (currently C.UTF-8, C.utf8, and UTF-8). The default error handler for stderr continues to be backslashreplace, regardless of locale.Locale coercion is silent by default, but to assist in debugging potentially locale related integration problems, explicit warnings (emitted directly on stderr) can be requested by setting PYTHONCOERCECLOCALE=warn. This setting will also cause the Python runtime to emit a warning if the legacy C locale remains active when the core interpreter is initialized.While PEP 538’s locale coercion has the benefit of also affecting extension modules (such as GNU readline), as well as child processes (including those running non-Python applications and older versions of Python), it has the downside of requiring that a suitable target locale be present on the running system. To better handle the case where no suitable target locale is available (as occurs on RHEL/CentOS 7, for example), Python 3.7 also implements PEP 540: Forced UTF-8 Runtime Mode.See alsoPEP 538 – Coercing the legacy C locale to a UTF-8 based localePEP written and implemented by Nick Coghlan.PEP 540: Forced UTF-8 Runtime ModeThe new -X utf8 command line option and PYTHONUTF8 environment variable can be used to enable the CPython UTF-8 mode.When in UTF-8 mode, CPython ignores the locale settings, and uses the UTF-8 encoding by default. The error handlers for sys.stdin and sys.stdout streams are set to surrogateescape.The forced UTF-8 mode can be used to change the text handling behavior in an embedded Python interpreter without changing the locale settings of an embedding application.While PEP 540’s UTF-8 mode has the benefit of working regardless of which locales are available on the running system, it has the downside of having no effect on extension modules (such as GNU readline), child processes running non-Python applications, and child processes running older versions of Python. To reduce the risk of corrupting text data when communicating with such components, Python 3.7 also implements PEP 540: Forced UTF-8 Runtime Mode).The UTF-8 mode is enabled by default when the locale is C or POSIX, and the PEP 538 locale coercion feature fails to change it to a UTF-8 based alternative (whether that failure is due to PYTHONCOERCECLOCALE=0 being set, LC_ALL being set, or the lack of a suitable target locale).See alsoPEP 540 – Add a new UTF-8 modePEP written and implemented by Victor StinnerPEP 553: Built-in breakpoint()Python 3.7 includes the new built-in breakpoint() function as an easy and consistent way to enter the Python debugger.Built-in breakpoint() calls sys.breakpointhook(). By default, the latter imports pdb and then calls pdb.set_trace(), but by binding sys.breakpointhook() to the function of your choosing, breakpoint() can enter any debugger. Additionally, the environment variable PYTHONBREAKPOINT can be set to the callable of your debugger of choice. Set PYTHONBREAKPOINT=0 to completely disable built-in breakpoint().See alsoPEP 553 – Built-in breakpoint()PEP written and implemented by Barry WarsawPEP 539: New C API for Thread-Local StorageWhile Python provides a C API for thread-local storage support; the existing Thread Local Storage (TLS) API has used int to represent TLS keys across all platforms. This has not generally been a problem for officially-support platforms, but that is neither POSIX-compliant, nor portable in any practical sense.PEP 539 changes this by providing a new Thread Specific Storage (TSS) API to CPython which supersedes use of the existing TLS API within the CPython interpreter, while deprecating the existing API. The TSS API uses a new type Py_tss_t instead of int to represent TSS keys–an opaque type the definition of which may depend on the underlying TLS implementation. Therefore, this will allow to build CPython on platforms where the native TLS key is defined in a way that cannot be safely cast to int.Note that on platforms where the native TLS key is defined in a way that cannot be safely cast to int, all functions of the existing TLS API will be no-op and immediately return failure. This indicates clearly that the old API is not supported on platforms where it cannot be used reliably, and that no effort will be made to add such support.See alsoPEP 539 – A New C-API for Thread-Local Storage in CPythonPEP written by Erik M. Bray; implementation by Masayuki Yamamoto.PEP 562: Customization of Access to Module AttributesPython 3.7 allows defining __getattr__() on modules and will call it whenever a module attribute is otherwise not found. Defining __dir__() on modules is now also allowed.A typical example of where this may be useful is module attribute deprecation and lazy loading.See alsoPEP 562 – Module __getattr__ and __dir__PEP written and implemented by Ivan LevkivskyiPEP 564: New Time Functions With Nanosecond ResolutionThe resolution of clocks in modern systems can exceed the limited precision of a floating point number returned by the time.time() function and its variants. To avoid loss of precision, PEP 564 adds six new nanosecond” variants of the existing timer functions to the time module:time.clock_gettime_ns()time.clock_settime_ns()time.monotonic_ns()time.perf_counter_ns()time.process_time_ns()time.time_ns()The new functions return the number of nanoseconds as an integer value.Measurements show that on Linux and Windows the resolution of time.time_ns() is approximately 3 times better than that of time.time().See alsoPEP 564 – Add new time functions with nanosecond resolutionPEP written and implemented by Victor StinnerPEP 565: Show DeprecationWarning in __main__The default handling of DeprecationWarning has been changed such that these warnings are once more shown by default, but only when the code triggering them is running directly in the __main__ module. As a result, developers of single file scripts and those using Python interactively should once again start seeing deprecation warnings for the APIs they use, but deprecation warnings triggered by imported application, library and framework modules will continue to be hidden by default.As a result of this change, the standard library now allows developers to choose between three different deprecation warning behaviours:FutureWarning: always displayed by default, recommended for warnings intended to be seen by application end users (e.g. for deprecated application configuration settings).DeprecationWarning: displayed by default only in __main__ and when running tests, recommended for warnings intended to be seen by other Python developers where a version upgrade may result in changed behaviour or an error.PendingDeprecationWarning: displayed by default only when running tests, intended for cases where a future version upgrade will change the warning category to DeprecationWarning or FutureWarning.Previously both DeprecationWarning and PendingDeprecationWarning were only visible when running tests, which meant that developers primarily writing single file scripts or using Python interactively could be surprised by breaking changes in the APIs they used.See alsoPEP 565 – Show DeprecationWarning in __main__PEP written and implemented by Nick CoghlanPEP 560: Core Support for typing module and Generic TypesInitially PEP 484 was designed in such way that it would not introduce any changes to the core CPython interpreter. Now type hints and the typing module are extensively used by the community, so this restriction is removed. The PEP introduces two special methods __class_getitem__() and __mro_entries__, these methods are now used by most classes and special constructs in typing. As a result, the speed of various operations with types increased up to 7 times, the generic types can be used without metaclass conflicts, and several long standing bugs in typing module are fixed.See alsoPEP 560 – Core support for typing module and generic typesPEP written and implemented by Ivan LevkivskyiPEP 552: Hash-based .pyc FilesPython has traditionally checked the up-to-dateness of bytecode cache files (i.e., .pyc files) by comparing the source metadata (last-modified timestamp and size) with source metadata saved in the cache file header when it was generated. While effective, this invalidation method has its drawbacks. When filesystem timestamps are too coarse, Python can miss source updates, leading to user confusion. Additionally, having a timestamp in the cache file is problematic for build reproducibility and content-based build systems.PEP 552 extends the pyc format to allow the hash of the source file to be used for invalidation instead of the source timestamp. Such .pyc files are called hash-based”. By default, Python still uses timestamp-based invalidation and does not generate hash-based .pyc files at runtime. Hash-based .pyc files may be generated with py_compile or compileall.Hash-based .pyc files come in two variants: checked and unchecked. Python validates checked hash-based .pyc files against the corresponding source files at runtime but doesn’t do so for unchecked hash-based pycs. Unchecked hash-based .pyc files are a useful performance optimization for environments where a system external to Python (e.g., the build system) is responsible for keeping .pyc files up-to-date.See Cached bytecode invalidation for more information.See alsoPEP 552 – Deterministic pycsPEP written and implemented by Benjamin PetersonPEP 545: Python Documentation TranslationsPEP 545 describes the process of creating and maintaining Python documentation translations.Three new translations have been added:Japanese: https://docs.python.org/ja/French: https://docs.python.org/fr/Korean: https://docs.python.org/ko/See alsoPEP 545 – Python Documentation TranslationsPEP written and implemented by Julien Palard, Inada Naoki, and Victor Stinner.Development Runtime Mode: -X devThe new -X dev command line option or the new PYTHONDEVMODE environment variable can be used to enable CPython’s development mode. When in development mode, CPython performs additional runtime checks that are too expensive to be enabled by default. See -X dev documentation for the full description of the effects of this mode.Other Language ChangesMore than 255 arguments can now be passed to a function, and a function can now have more than 255 parameters. (Contributed by Serhiy Storchaka in  and .)bytes.fromhex() and bytearray.fromhex() now ignore all ASCII whitespace, not only spaces. (Contributed by Robert Xiao in .)str, bytes, and bytearray gained support for the new isascii() method, which can be used to test if a string or bytes contain only the ASCII characters. (Contributed by INADA Naoki in .)ImportError now displays module name and module __file__ path when from ... import ... fails. (Contributed by Matthias Bussonnier in .)Circular imports involving absolute imports with binding a submodule to a name are now supported. (Contributed by Serhiy Storchaka in .)object.__format__(x, ) is now equivalent to str(x) rather than format(str(self), ). (Contributed by Serhiy Storchaka in .)In order to better support dynamic creation of stack traces, types.TracebackType can now be instantiated from Python code, and the tb_next attribute on tracebacks is now writable. (Contributed by Nathaniel J. Smith in .)When using the -m switch, sys.path[0] is now eagerly expanded to the full starting directory path, rather than being left as the empty directory (which allows imports from the current working directory at the time when an import occurs) (Contributed by Nick Coghlan in .)The new -X importtime option or the PYTHONPROFILEIMPORTTIME environment variable can be used to show the timing of each module import. (Contributed by Victor Stinner in .)New ModulescontextvarsThe new contextvars module and a set of new C APIs introduce support for context variables. Context variables are conceptually similar to thread-local variables. Unlike TLS, context variables support asynchronous code correctly.The asyncio and decimal modules have been updated to use and support context variables out of the box. Particularly the active decimal context is now stored in a context variable, which allows decimal operations to work with the correct context in asynchronous code.See alsoPEP 567 – Context VariablesPEP written and implemented by Yury SelivanovdataclassesThe new dataclass() decorator provides a way to declare data classes. A data class describes its attributes using class variable annotations. Its constructor and other magic methods, such as __repr__(), __eq__(), and __hash__() are generated automatically.Example:@dataclassclass Point:    x: float    y: float    z: float = 0.0p = Point(1.5, 2.5)print(p)   # produces Point(x=1.5, y=2.5, z=0.0)See alsoPEP 557 – Data ClassesPEP written and implemented by Eric V. Smithimportlib.resourcesThe new importlib.resources module provides several new APIs and one new ABC for access to, opening, and reading resources inside packages. Resources are roughly similar to files inside packages, but they needn’t be actual files on the physical file system. Module loaders can provide a get_resource_reader() function which returns a importlib.abc.ResourceReader instance to support this new API. Built-in file path loaders and zip file loaders both support this.Contributed by Barry Warsaw and Brett Cannon in .See also importlib_resources – a PyPI backport for earlier Python versions.Improved ModulesargparseThe new ArgumentParser.parse_intermixed_args() method allows intermixing options and positional arguments. (Contributed by paul.j3 in .)asyncioThe asyncio module has received many new features, usability and performance improvements. Notable changes include:The new provisional asyncio.run() function can be used to run a coroutine from synchronous code by automatically creating and destroying the event loop. (Contributed by Yury Selivanov in .)asyncio gained support for contextvars. loop.call_soon(), loop.call_soon_threadsafe(), loop.call_later(), loop.call_at(), and Future.add_done_callback() have a new optional keyword-only context parameter. Tasks now track their context automatically. See PEP 567 for more details. (Contributed by Yury Selivanov in .)The new asyncio.create_task() function has been added as a shortcut to asyncio.get_event_loop().create_task(). (Contributed by Andrew Svetlov in .)The new loop.start_tls() method can be used to upgrade an existing connection to TLS. (Contributed by Yury Selivanov in .)The new loop.sock_recv_into() method allows reading data from a socket directly into a provided buffer making it possible to reduce data copies. (Contributed by Antoine Pitrou in .)The new asyncio.current_task() function returns the currently running Task instance, and the new asyncio.all_tasks() function returns a set of all existing Task instances in a given loop. The Task.current_task() and Task.all_tasks() methods have been deprecated. (Contributed by Andrew Svetlov in .)The new provisional BufferedProtocol class allows implementing streaming protocols with manual control over the receive buffer. (Contributed by Yury Selivanov in .)The new asyncio.get_running_loop() function returns the currently running loop, and raises a RuntimeError if no loop is running. This is in contrast with asyncio.get_event_loop(), which will create a new event loop if none is running. (Contributed by Yury Selivanov in .)The new StreamWriter.wait_closed() coroutine method allows waiting until the stream writer is closed. The new StreamWriter.is_closing() method can be used to determine if the writer is closing. (Contributed by Andrew Svetlov in .)The new loop.sock_sendfile() coroutine method allows sending files using os.sendfile when possible. (Contributed by Andrew Svetlov in .)The new Future.get_loop() and Task.get_loop() methods return the instance of the loop on which a task or a future were created. Server.get_loop() allows doing the same for asyncio.Server objects. (Contributed by Yury Selivanov in  and Srinivas Reddy Thatiparthy in .)It is now possible to control how instances of asyncio.Server begin serving. Previously, the server would start serving immediately when created. The new start_serving keyword argument to loop.create_server() and loop.create_unix_server(), as well as Server.start_serving(), and Server.serve_forever() can be used to decouple server instantiation and serving. The new Server.is_serving() method returns True if the server is serving. Server objects are now asynchronous context managers:srv = await loop.create_server(...)async with srv:    # some code# At this point, srv is closed and no longer accepts new connections.(Contributed by Yury Selivanov in .)Callback objects returned by loop.call_later() gained the new when() method which returns an absolute scheduled callback timestamp. (Contributed by Andrew Svetlov in .)The loop.create_datagram_endpoint() method gained support for Unix sockets. (Contributed by Quentin Dawans in .)The asyncio.open_connection(), asyncio.start_server() functions, loop.create_connection(), loop.create_server(), loop.create_accepted_socket() methods and their corresponding UNIX socket variants now accept the ssl_handshake_timeout keyword argument. (Contributed by Neil Aspinall in .)The new Handle.cancelled() method returns True if the callback was cancelled. (Contributed by Marat Sharafutdinov in .)The asyncio source has been converted to use the async/await syntax. (Contributed by Andrew Svetlov in .)The new ReadTransport.is_reading() method can be used to determine the reading state of the transport. Additionally, calls to ReadTransport.resume_reading() and ReadTransport.pause_reading() are now idempotent. (Contributed by Yury Selivanov in .)Loop methods which accept socket paths now support passing path-like objects. (Contributed by Yury Selivanov in .)In asyncio TCP sockets on Linux are now created with TCP_NODELAY flag set by default. (Contributed by Yury Selivanov and Victor Stinner in .)Exceptions occurring in cancelled tasks are no longer logged. (Contributed by Yury Selivanov in .)New WindowsSelectorEventLoopPolicy and WindowsProactorEventLoopPolicy classes. (Contributed by Yury Selivanov in .)Several asyncio APIs have been deprecated.binasciiThe b2a_uu() function now accepts an optional backtick keyword argument. When it’s true, zeros are represented by ` instead of spaces. (Contributed by Xiang Zhang in .)calendarThe HTMLCalendar class has new class attributes which ease the customization of CSS classes in the produced HTML calendar. (Contributed by Oz Tiram in .)collectionscollections.namedtuple() now supports default values. (Contributed by Raymond Hettinger in .)compileallcompileall.compile_dir() learned the new invalidation_mode parameter, which can be used to enable hash-based .pyc invalidation. The invalidation mode can also be specified on the command line using the new --invalidation-mode argument. (Contributed by Benjamin Peterson in .)concurrent.futuresProcessPoolExecutor and ThreadPoolExecutor now support the new initializer and initargs constructor arguments. (Contributed by Antoine Pitrou in .)The ProcessPoolExecutor can now take the multiprocessing context via the new mp_context argument. (Contributed by Thomas Moreau in .)contextlibThe new nullcontext() is a simpler and faster no-op context manager than ExitStack. (Contributed by Jesse-Bakker in .)The new asynccontextmanager(), AbstractAsyncContextManager, and AsyncExitStack have been added to complement their synchronous counterparts. (Contributed by Jelle Zijlstra in  and , and by Alexander Mohr and Ilya Kulakov in .)cProfileThe cProfile command line now accepts -m module_name as an alternative to script path. (Contributed by Sanyam Khurana in .)cryptThe crypt module now supports the Blowfish hashing method. (Contributed by Serhiy Storchaka in .)The mksalt() function now allows specifying the number of rounds for hashing. (Contributed by Serhiy Storchaka in .)datetimeThe new datetime.fromisoformat() method constructs a datetime object from a string in one of the formats output by datetime.isoformat(). (Contributed by Paul Ganssle in .)The tzinfo class now supports sub-minute offsets. (Contributed by Alexander Belopolsky in .)dbmdbm.dumb now supports reading read-only files and no longer writes the index file when it is not changed.decimalThe decimal module now uses context variables to store the decimal context. (Contributed by Yury Selivanov in .)disThe dis() function is now able to disassemble nested code objects (the code of comprehensions, generator expressions and nested functions, and the code used for building nested classes). The maximum depth of disassembly recursion is controlled by the new depth parameter. (Contributed by Serhiy Storchaka in .)distutilsREADME.rst is now included in the list of distutils standard READMEs and therefore included in source distributions. (Contributed by Ryan Gonzalez in .)enumThe Enum learned the new _ignore_ class property, which allows listing the names of properties which should not become enum members. (Contributed by Ethan Furman in .)In Python 3.8, attempting to check for non-Enum objects in Enum classes will raise a TypeError (e.g. 1 in Color); similarly, attempting to check for non-Flag objects in a Flag member will raise TypeError (e.g. 1 in Perm.RW); currently, both operations return False instead and are deprecated. (Contributed by Ethan Furman in .)functoolsfunctools.singledispatch() now supports registering implementations using type annotations. (Contributed by Łukasz Langa in .)gcThe new gc.freeze() function allows freezing all objects tracked by the garbage collector and excluding them from future collections. This can be used before a POSIX fork() call to make the GC copy-on-write friendly or to speed up collection. The new gc.unfreeze() functions reverses this operation. Additionally, gc.get_freeze_count() can be used to obtain the number of frozen objects. (Contributed by Li Zekun in .)hmacThe hmac module now has an optimized one-shot digest() function, which is up to three times faster than HMAC(). (Contributed by Christian Heimes in .)http.clientHTTPConnection and HTTPSConnection now support the new blocksize argument for improved upload throughput. (Contributed by Nir Soffer in .)http.serverSimpleHTTPRequestHandler now supports the HTTP If-Modified-Since header. The server returns the 304 response status if the target file was not modified after the time specified in the header. (Contributed by Pierre Quentel in .)SimpleHTTPRequestHandler accepts the new directory argument, in addition to the new --directory command line argument. With this parameter, the server serves the specified directory, by default it uses the current working directory. (Contributed by Stéphane Wirtel and Julien Palard in .)The new ThreadingHTTPServer class uses threads to handle requests using ThreadingMixin. It is used when http.server is run with -m. (Contributed by Julien Palard in .)idlelib and IDLEMultiple fixes for autocompletion. (Contributed by Louie Lu in .)Module Browser (on the File menu, formerly called Class Browser), now displays nested functions and classes in addition to top-level functions and classes. (Contributed by Guilherme Polo, Cheryl Sabella, and Terry Jan Reedy in .)The Settings dialog (Options, Configure IDLE) has been partly rewritten to improve both appearance and function. (Contributed by Cheryl Sabella and Terry Jan Reedy in multiple issues.)The font sample now includes a selection of non-Latin characters so that users can better see the effect of selecting a particular font. (Contributed by Terry Jan Reedy in .) The sample can be edited to include other characters. (Contributed by Serhiy Storchaka in .)The IDLE features formerly implemented as extensions have been reimplemented as normal features. Their settings have been moved from the Extensions tab to other dialog tabs. (Contributed by Charles Wohlganger and Terry Jan Reedy in .)Editor code context option revised. Box displays all context lines up to maxlines. Clicking on a context line jumps the editor to that line. Context colors for custom themes is added to Highlights tab of Settings dialog. (Contributed by Cheryl Sabella and Terry Jan Reedy in , , and .)On Windows, a new API call tells Windows that tk scales for DPI. On Windows 8.1+ or 10, with DPI compatibility properties of the Python binary unchanged, and a monitor resolution greater than 96 DPI, this should make text and lines sharper. It should otherwise have no effect. (Contributed by Terry Jan Reedy in .)New in 3.7.1:Output over N lines (50 by default) is squeezed down to a button. N can be changed in the PyShell section of the General page of the Settings dialog. Fewer, but possibly extra long, lines can be squeezed by right clicking on the output. Squeezed output can be expanded in place by double-clicking the button or into the clipboard or a separate window by right-clicking the button. (Contributed by Tal Einat in .)The changes above have been backported to 3.6 maintenance releases.importlibThe importlib.abc.ResourceReader ABC was introduced to support the loading of resources from packages. See also importlib.resources. (Contributed by Barry Warsaw, Brett Cannon in .)importlib.reload() now raises ModuleNotFoundError if the module lacks a spec. (Contributed by Garvit Khatri in .)importlib.find_spec() now raises ModuleNotFoundError instead of AttributeError if the specified parent module is not a package (i.e. lacks a __path__ attribute). (Contributed by Milan Oberkirch in .)The new importlib.source_hash() can be used to compute the hash of the passed source. A hash-based .pyc file embeds the value returned by this function.ioThe new TextIOWrapper.reconfigure() method can be used to reconfigure the text stream with the new settings. (Contributed by Antoine Pitrou in  and INADA Naoki in .)ipaddressThe new subnet_of() and supernet_of() methods of ipaddress.IPv6Network and ipaddress.IPv4Network can be used for network containment tests. (Contributed by Michel Albert and Cheryl Sabella in .)itertoolsitertools.islice() now accepts integer-like objects as start, stop, and slice arguments. (Contributed by Will Roberts in .)localeThe new monetary argument to locale.format_string() can be used to make the conversion use monetary thousands separators and grouping strings. (Contributed by Garvit in .)The locale.getpreferredencoding() function now always returns UTF-8 on Android or when in the forced UTF-8 mode.loggingLogger instances can now be pickled. (Contributed by Vinay Sajip in .)The new StreamHandler.setStream() method can be used to replace the logger stream after handler creation. (Contributed by Vinay Sajip in .)It is now possible to specify keyword arguments to handler constructors in configuration passed to logging.config.fileConfig(). (Contributed by Preston Landers in .)math